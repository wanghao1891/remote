* 参考
** 4. [[http://www.scheme.com/tspl4/preface.html#./preface:h0][Preface The Scheme Programming Language, Fourth Edition]] [2015-09-20 Sun 22:52]
** 3. [[https://en.wikipedia.org/wiki/Scheme_(programming_language)][Scheme (programming language) Wikipedia]] [2015-09-20 Sun 22:49]
** 2. [[https://zh.wikipedia.org/wiki/Scheme][Scheme 维基百科]] [2015-09-20 Sun 22:45]
** 1. [[https://www.ibm.com/developerworks/cn/linux/l-scheme/part2/][Scheme 程序语言介绍之一]] [2015-09-20 Sun 22:43]

* 简介

**
  Scheme 的前身是 Lisp。和 Scheme 一样，这也是一门诞生在 MIT 人工智能实验室的语言。 据说 Lisp 在程序语言的族谱上，班辈仅次于 Fortran，是第二古老的语言。但和 Fortran 不同，Fortran 经常被大名鼎鼎的计算机科学家批评，作为反面教材，这些计算机科学家当 中有著名的图灵奖获得者 Edsger Dijkstra。而 Lisp 和 Scheme 恰恰相反，它们常被计算 机科学家作为正面例子，一个优秀作品的例子。赞扬 Lisp 的人当中有 Smalltalk 和图形 用户界面的发明人之一 Alan Kay。
  Lisp 由图灵奖获得者 John McCarthy 发明。据说一开始 McCarthy 只想把这门他正在设计 的语言的语法的设计，往后拖一拖，等到后面有趣的工作做完了，再回头来给这门基于 Lambda 演算的程序语言加上为数学家们所熟悉的语法。可是 McCarthy 的一个学生很快发 现，直接在还没有正式语法的抽象语法里面写程序，感觉非常好。就用不着一个正式的语法 了。于是 Lisp 诞生了。Lisp 重要的特征就是：第一，基于 Lambda 演算的计算模型；第 二，加上 List processing，这也是 Lisp 名称的由来；第三，直接在抽象语法里面工作， 这是非常特别的。前两个重要特征，是 McCarthy 天才的设计，第三个特征则是有趣的巧合。

  又过了十多年，还在 MIT 人工智能实验室，不过这次不是 McCarthy，而是两个更年轻的计算机科学家。Guy Steele, Jr. 和他的老师 Gerald Sussman 合作对古典 Lisp 做了两个重 要改进。一是把 Lisp 从 Dynamic scope 变成了 Lexical scope。现在大家熟悉的几乎所 有的语言都是 Lexical scope，所以大家见怪不怪了。后来 Steele 成为 Common Lisp 设 计的主力，Common Lisp 把 Scheme 的 Lexical scope、还有其它一些由 Scheme 所创造的 特征，都加入到主流 Lisp 语言当中，Dynamic scope 终于成为了历史。Steele 和 Sussman 做的另一个主要改进是把 Continuation 这个概念引入到程序语言里面。这样一门 新的程序语言就此诞生。他们按照人工智能实验室的传统，把它命名为 Scheme。

**
  Scheme是一种函数式编程语言，是Lisp的两种主要方言之一（另一种为Common Lisp）。不同于Common Lisp，Scheme遵循极简主义哲学，以一个小型语言核心作为标准，加上各种强力语言工具（语法糖）来扩展语言本身。

  麻省理工学院与其他院校曾采用Scheme教授计算机科学入门课程。著名的入门教材《计算机程序的构造和解释》（SICP，或称“魔法书”）利用Scheme来解释程序设计。Scheme的广泛受众被视为一个主要优势，然而不同实现之间的差异成为了它的一个劣势。

  Scheme最早由麻省理工学院(MIT AI Lab)的盖伊·史提尔二世(Guy L. Steele)与杰拉德·杰伊·萨斯曼(Gerald Jay Sussman)在1970年代发展出来，并由两人发表的“λ论文集”推广开来。 Scheme语言与λ演算关系十分密切。小写字母“λ”是Scheme语言的标志。

  Scheme的哲学是：设计计算机语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。Scheme是第一个使用静态作用域的Lisp方言，也是第一个引入“干净宏”和第一类续延的编程语言。

**
  Scheme was introduced in 1975 by Gerald J. Sussman and Guy L. Steele, and was the first dialect of Lisp to fully support lexical scoping, first-class procedures, and continuations. In its earliest form it was a small language intended primarily for research and teaching, supporting only a handful of predefined syntactic forms and procedures. Scheme is now a complete general-purpose programming language, though it still derives its power from a small set of key concepts. Early implementations of the language were interpreter-based and slow, but some current Scheme implementations boast sophisticated compilers that generate code on par with code generated by the best optimizing compilers for lower-level languages such as C and Fortran.

** lisp
   Scheme起源于约翰·麦卡锡(John McCarthy)于1958年提出的Lisp语言。通过Lisp，麦卡锡证明了图灵完备的系统可以仅仅由几个简单的算子与函数定义功能组成。这一设计对Scheme的影响非常深刻。

   麦卡锡最早提出两套语法：所谓“M表示式”是通常熟知的函数语法，如car[cons[A,B]]。在麦卡锡原本的设计中，用M表示式写成的程序将自动译至“S表示式”，如(car (cons A B))，然而由于S表示式具备homoiconic的特性（即程序与数据由相同的结构存储），实际应用中一般只使用S表示式。Scheme的语法即来自S表示式。这一特性使得在Scheme中实现自循环解释器变得非常简单。

** scheme
   lisp                       --> scheme
   1958                       --> 1975
   约翰·麦卡锡(John McCarthy) --> 盖伊·史提尔二世(Guy L. Steele)与杰拉德·杰伊·萨斯曼(Gerald Jay Sussman)

   lisp dialect
   common lisp
   S-expression
   λ lambada
   lexical scoping
   first-class procedures
   continuations


   Scheme 是一种函数式编程语言，但又不是纯的，它允许副作用的存在。Haskell 是一种纯的函数式编程语言。

   Scheme 是 Lisp 的两种主要方言之一，另外一种是 Common Lisp。

   不同于 Common Lisp，Scheme 遵循极简主义哲学，以一个小型语言核心作为标准，加上各种强力语言工具（语法糖）来扩展语言本身。

   Scheme 的哲学是：设计计算机语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。

   Lisp 和 Scheme 都是诞生在 MIT 人工智能实验室(MIT AI Lab)的语言。

   Lisp 是约翰·麦卡锡(John McCarthy)在1958年提出来的。

   Scheme 是盖伊·史提尔二世(Guy L. Steele)与杰拉德·杰伊·萨斯曼(Gerald Jay Sussman)在1975发展出来的。并由两人发表的“λ论文集”推广开来。 Scheme语言与λ演算关系十分密切。小写字母“λ”是 Scheme 语言的标志。

   Lisp 和 Scheme 的区别：
   Lisp 采用动态作用域(dynamic scope)；
   Scheme 采用静态作用域(lexical scope)；
   Scheme中引入了延续(continuation)等特性。

   Lisp和Scheme都采用S表达式(S-expression)来作为基本的语法。

   S表达式的特点是，程序和数据由相同的数据结构存储(homoiconicity)，即代码即数据。

   Scheme使用


* 用途
  *

* 使用


* Scheme
  Scheme是一种函数式编程语言，是Lisp的两种主要方言之一（另一种为Common Lisp）。不同于Common Lisp，Scheme遵循极简主义哲学，以一个小型语言核心作为标准，加上各种强力语言工具（语法糖）来扩展语言本身。

  麻省理工学院与其他院校曾采用Scheme教授计算机科学入门课程。著名的入门教材《计算机程序的构造和解释》（SICP，或称“魔法书”）利用Scheme来解释程序设计。Scheme的广泛受众被视为一个主要优势，然而不同实现之间的差异成为了它的一个劣势。

  Scheme最早由麻省理工学院的盖伊·史提尔二世与杰拉德·杰伊·萨斯曼在1970年代发展出来，并由两人发表的“λ论文集”推广开来。 Scheme语言与λ演算关系十分密切。小写字母“λ”是Scheme语言的标志。

  Scheme的哲学是：设计计算机语言不应该进行功能的堆砌，而应该尽可能减少弱点和限制，使剩下的功能显得必要。Scheme是第一个使用静态作用域的Lisp方言，也是第一个引入“干净宏”和第一类续延的编程语言。

* 历史
** Lisp
   Scheme起源于约翰·麦卡锡于1958年提出的Lisp语言。通过Lisp，麦卡锡证明了图灵完备的系统可以仅仅由几个简单的算子与函数定义功能组成。这一设计对Scheme的影响非常深刻。

   麦卡锡最早提出两套语法：所谓“M表示式”是通常熟知的函数语法，如car[cons[A,B]]。在麦卡锡原本的设计中，用M表示式写成的程序将自动译至“S表示式”，如(car (cons A B))，然而由于S表示式具备homoiconic的特性（即程序与数据由相同的结构存储），实际应用中一般只使用S表示式。Scheme的语法即来自S表示式。这一特性使得在Scheme中实现自循环解释器变得非常简单。

** 起源
   Scheme的灵感来自麻省理工学院的Carl Hewitt提出的一种叫做参与者模式的数学模型。Hewitt当时正在试图将参与者模式加入Planner语言，而受其影响的史提尔与萨斯曼决定在Maclisp中实现一个支持参与者模式的Lisp方言。史提尔与萨斯曼两人很快发现参与者模式与λ演算非常类似，而所谓“参与者”不过是Peter J. Landin提出并由Joel Moses于1970年发表的闭包而已。因此，两人很快意识到λ演算是在Lisp中实现变数范围的关键。基于这一见解，两人很快开发出了一套精简的编程语言，并命名为“Schemer”（后因操作系统字数限制改为Scheme）。尽管Hewitt认为Scheme抽象性的不足是一个倒退，它简约的语法很快赢得广泛接受，并成为最具影响力的编程语言之一。在Scheme被广为接受后，史提尔与萨斯曼曾承认他们事实上没有刻意实现Scheme的简约性。两人认为简单而强大的λ演算最终使得Scheme得以实现极度的精简化。

** λ论文集
   “λ论文集”是Scheme的发明人史提尔与萨斯曼所撰写的关于编程语言设计的一系列论文，最早作为麻省理工学院的内部备忘录发表。Scheme的功能很大一部分是由这些论文确立的。 通常认为λ论文集包括：
   - Scheme: An Interpreter for Extended Lambda Calculus，1975年
   - Lambda: The Ultimate Imperative，1976年
   - Lambda: The Ultimate Declarative，1976年
   - Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO，1977年
   - The Art of the Interpreter or, the Modularity Complex (Parts Zero, One, and Two)，1978年
   - RABBIT: A Compiler for SCHEME，1978年
   - Design of LISP-based Processors, or SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode，1979年
   - Compiler Optimization Based on Viewing LAMBDA as RENAME + GOTO，1980年
Design of a Lisp-based Processor，1980年

* 语言标准
  目前Scheme由IEEE负责标准管理，并由一个专门的委员会发表的“算法语言Scheme报告，第N版”（Revisedn Report on the Algorithmic Language Scheme）进行标准化。现在的标准是1998年的R5RS，并且R6RS已经在2007年被批准了。R6RS带来了很大的变动，导致Scheme社区对其意见不一，更有一些用户指责R6RS仅仅是在堆积华而不实的功能。

  Scheme的标准委员会目前正在讨论R7RS的事宜，并决定是否将Scheme分为两个独立的语言：一个为教育者提供精简的语法，另一个为专业人士提供强大的功能。

* 语言特性
  Scheme大体上是一个函数式编程语言，并支持其他编程范型。它的语法基于Lisp的S-表达式：函数调用在Scheme中表示为一个串列，其中第一个元素为函数名，而后的元素为函数的参数。一个Scheme程序是由嵌套串列表达而成，而串列又是Scheme的主要数据结构，这导致程序和数据在Scheme中基本上是等价的概念。因此每一个Scheme程序都可以被视为另一个Scheme程序的参数。Scheme程序可以轻易读入并分析其他Scheme程序，就是所谓的同像性。该特性被用于“代码即数据”的设计思维中，它极大提高了语言表达性和灵活性。但也有批评认为对该特性的不当使用将造成反效果，将数据当作代码需要借助eval在运行时求值，这不利于编译优化；另外代码可以被当作数据一样被修改（即所谓程序自修改）可能会造成程序逻辑混乱。

  Scheme的列表与其他Lisp方言都是基于最基础的数据结构“有序对”（pair）。Scheme提供cons，car，与cdr方法操作有序对与列表。

  Scheme的变数都使用动态强类型系统，而函数被视为变数的一种，并可以作为参数提供给其他函数。换句话说，Scheme中的函数都是第一类对象。

** 极简主义
   Scheme的简约性使它成为具备同级别功能的编程语言中最易于实现的语言。Scheme的很多结构源于λ演算，例如let可以写作创造并调用一个匿名函数：

   (define-syntax let
     (syntax-rules ()
       ((let ((var expr) ...) body ...)
         ((lambda (var ...) body ...) expr ...))))

   换句话说，调用let语句如(let ((a 1) (b 2)) (+ a b))等同于λ演算语句((lambda (a b) (+ a b)) 1 2)。 基于这一特性，Scheme的解释器可以得到极大的精简。

** λ演算
   Scheme的函数式范型主要受到了邱奇的λ演算的影响。在Scheme中，“lambda”关键词被用于定义匿名函数，且所有非匿名函数都可以被视作取值为lambda函数的变数。（换句话说，(define (foo x) (+ x 1))与(define foo (lambda (x) (+ x 1)))在语法上是等同的，而前者在解释器中会被译为后者。）这一设置在历史上推动了函数式编程语言的发展。

** 代码块结构
   Scheme的代码块结构来自更早时候的ALGOL语言。在Scheme中，本地变数可以由let，let*，与letrec产生。这些语句实际上与lambda等同：它们都通过函数的形式参数来实现本地变数。例如，

   (define foo 5)
   ;; foo 現在取值 5
   (let ((foo 10))
     ;; foo 現在取值 10
     )
   ;; foo 現在取值 5

** 尾递归优化
   Scheme是最早实现尾部递归优化的Lisp方言。换句话说，Scheme中所有尾部递归都会被自动作为循环解释（Scheme支持do语句，但是一般Scheme中循环都会写作递归）。尾部递归优化使得Scheme支持任意数目的尾部递归调用，而无需担心堆栈溢出。如以下计算阶乘的程序将自动优化为循环。

   (define (factorial n)
     (define (iter product counter)
       (if (> counter n)
           product
           (iter (* counter product)
                 (+ counter 1))))
     (iter 1 1))

* 语言元素
  根据Scheme语言规范，Scheme中的标准语句可分为“标准模式”（Standard form）与“标准过程”（Standard procedure），其中标准模式提供语言的控制结构，而标准过程提供一些常用的功能。

* 实现
  Scheme的精简设计使得编程语言设计人士与爱好者特别钟爱研究它的实现，很多嵌入式系统语言与脚本语言即是基于Scheme。Scheme的实现一般小而精简，造成了很多不可互通的实现互相竞争。尽管Scheme的精简性是它的一个主要长处，但试图使用Scheme编写既复杂又便于移植的程序往往比较困难，主要原因之一，是因为Scheme没有库函数标准。而R6RS试图完成这样的工作，它定义了两套标准，核心语言以及标准库。这使得Scheme第一次有了库函数标准，也使得编译器开发者和贡献者可以实现Scheme的可移植库。

  几乎所有Scheme实现都是基于Lisp的“读取–求值–输出循环”（read–eval–print loop）模式。一些Scheme实现亦可作为编译器，并将Scheme程序译为二进制码。很多用类似C的基础语言写成的软件都利用Scheme作为脚本语言。还有一些Scheme翻译器（例如Gambit，Chicken，Bigloo等）可将Scheme程序译为C或Java，或甚至.Net。将Scheme译作C的翻译器往往可以在源代码中利用C的特性。

  最基本的Scheme实现是在《计算机程序的构造和解释》中实现的自循环解释器。这一解释器以Scheme写成，并利用底层的Scheme功能来实现被运行的Scheme语言程序。尽管在实际上这一解释器的意义不大（要想运行自循环解释器，计算机中必须已经存在一个Scheme解释器），它简单的语法可以帮助用户理解Scheme的运行过程。

* 实际用处
** 计算机科学教育
   很多著名的计算机科学院校都利用Scheme来教授入门级课程。以下为一些最为著名的教授Scheme的学校：

   - 麻省理工学院是Scheme与SICP的诞生地。直到2008年为止，麻省理工学院的入门课程6.001即是用Scheme来教授的。尽管现在Scheme已经不再被用于入门课程，麻省理工学院到目前为止还在教授SICP。
   - 伯克利加州大学的入门课程61A到2010年为止利用Scheme与SICP教授入门课程，并利用Scheme来实现Logo，另一个基于Lisp的编程语言。自2011年起，61A改用Python来教授SICP。
   - 西北大学的入门课程CS2500利用Scheme来教授另一本著名的教材《程序设计方法》。
   - 印第安那大学的入门课程C211利用Scheme来教授。
   - 耶鲁大学
   - 莱斯大学
   - ProgramByDesign项目在美国超过600所高中教授Scheme语言。
   - 滑铁卢大学数学系（包括computer science）的入门课程CS115,CS116利用Scheme来教授。
   - 云林科技大学

** 脚本语言
   - 自由软件视频处理程序GIMP利用Scheme为脚本语言。
   - GNU的标准脚本语言Guile是基于Scheme的，并被用于GNOME等软件中。
